{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started There's an expectation from every developer now a days. These are the set of tools that you require to get started before jumping inside a project. Setting up version control Any company immediately checks whether you have an Github account, it's like a developer's business card. Once you have created your account, give your github handle to your Techical Lead so he can add you to the company's team account. Learn the concepts of git like clone , push , pull , branches , merge , rebase and pull requests . You can look at Git tutorials here. Git Clients Git Fork (Free/Paid) Source Tree (Free) Git Tower (Paid) Magit (Free) CLI like a pro (Free) Tips Make sure you have a professional github handle, please don't use hammerplay name in it; Even if you leave us you still want to have that account. Don't work on the main branch, right after you create new repo, after adding README.md or .gitignore, create a develop branch and work from there. Plan your .gitignore from start or get it from another project. Folders like Builds should be ignored from the start, and shouldn't be accidently committed. Don't keep your project files inside sub folders. For example, Unity project should have Assets in the root of the git folder. Keep your projects organized in one projects folder. Naming conventions are very important, we'll cover more on that in best practices. Root git folder should be in smaller cases and use '-' as space. For example sheep-battle . When working with binary files like your images, sounds, textures, and scenes in a team; Communicate with the other team member otherwise you'll be stepping toes during git merge and losing data. Make smaller commits or follow git-flow method, it'll keep you organized. Communication Team work is essential at Hammerplay, we follow mostly Agile methodologies. To simplify the concepts, we don't have project managers, that means we have to communicate with the rest of the team ourselves, you need an asset?! you need to talk with your producer if there is one, or talk with the artist/developer directly. How do ideas form and who makes the call?! Scrum/floor discussion, we all just have a talk on what we want to achieve and what the project ideas are, we vote on the ideas as a group and make a list and try to go by that list. It's messy but it works best with creative projects. Milestones Once the project is discussed each of the team mate comes up with estimates on how long it'll take, and further break down these milestones as prototype, alpha, internal beta, public beta, and release , there are no work timings, we just expect the milestones to be done with the estimates that you have already given, some times estimates are off, please raise a flag if things are not going by your timings and talk to your team for newer action plans. Sync up atleast two times a week with your project mates. Emails? Slack? WhatsApp? Mails : Only use for official talks, like talking to a client, even though most of clients jump on Slack channels as well. WhatsApp : Avoid project discussions here unless you want to notify someone who is not reachable by Slack. You can say \"you're not coming for work\" , or \"you'll be late\" or just share memes. Slack : Post pandemic, Slack has completely changed how we work at our office. And moving forward we'll be using this method regardless. Projects are usually in each channels, so keep your project discussions inside that channel and don't bother people on direct messaging unless it's private. Floor : Floor talk is the easiet form so far, this is best for iterations, like going through assets, checking mechanics of a gameplay. Caution: You could be disturbing/distracting them from their work, respect their space and timings Workspace Write about office stuff, lunch, theatre room, devices/office assets checked out of office..etc Work timings, code of conduct","title":"Getting Started"},{"location":"#getting-started","text":"There's an expectation from every developer now a days. These are the set of tools that you require to get started before jumping inside a project.","title":"Getting Started"},{"location":"#setting-up-version-control","text":"Any company immediately checks whether you have an Github account, it's like a developer's business card. Once you have created your account, give your github handle to your Techical Lead so he can add you to the company's team account. Learn the concepts of git like clone , push , pull , branches , merge , rebase and pull requests . You can look at Git tutorials here.","title":"Setting up version control"},{"location":"#git-clients","text":"Git Fork (Free/Paid) Source Tree (Free) Git Tower (Paid) Magit (Free) CLI like a pro (Free)","title":"Git Clients"},{"location":"#tips","text":"Make sure you have a professional github handle, please don't use hammerplay name in it; Even if you leave us you still want to have that account. Don't work on the main branch, right after you create new repo, after adding README.md or .gitignore, create a develop branch and work from there. Plan your .gitignore from start or get it from another project. Folders like Builds should be ignored from the start, and shouldn't be accidently committed. Don't keep your project files inside sub folders. For example, Unity project should have Assets in the root of the git folder. Keep your projects organized in one projects folder. Naming conventions are very important, we'll cover more on that in best practices. Root git folder should be in smaller cases and use '-' as space. For example sheep-battle . When working with binary files like your images, sounds, textures, and scenes in a team; Communicate with the other team member otherwise you'll be stepping toes during git merge and losing data. Make smaller commits or follow git-flow method, it'll keep you organized.","title":"Tips"},{"location":"#communication","text":"Team work is essential at Hammerplay, we follow mostly Agile methodologies. To simplify the concepts, we don't have project managers, that means we have to communicate with the rest of the team ourselves, you need an asset?! you need to talk with your producer if there is one, or talk with the artist/developer directly.","title":"Communication"},{"location":"#how-do-ideas-form-and-who-makes-the-call","text":"Scrum/floor discussion, we all just have a talk on what we want to achieve and what the project ideas are, we vote on the ideas as a group and make a list and try to go by that list. It's messy but it works best with creative projects.","title":"How do ideas form and who makes the call?!"},{"location":"#milestones","text":"Once the project is discussed each of the team mate comes up with estimates on how long it'll take, and further break down these milestones as prototype, alpha, internal beta, public beta, and release , there are no work timings, we just expect the milestones to be done with the estimates that you have already given, some times estimates are off, please raise a flag if things are not going by your timings and talk to your team for newer action plans. Sync up atleast two times a week with your project mates.","title":"Milestones"},{"location":"#emails-slack-whatsapp","text":"Mails : Only use for official talks, like talking to a client, even though most of clients jump on Slack channels as well. WhatsApp : Avoid project discussions here unless you want to notify someone who is not reachable by Slack. You can say \"you're not coming for work\" , or \"you'll be late\" or just share memes. Slack : Post pandemic, Slack has completely changed how we work at our office. And moving forward we'll be using this method regardless. Projects are usually in each channels, so keep your project discussions inside that channel and don't bother people on direct messaging unless it's private. Floor : Floor talk is the easiet form so far, this is best for iterations, like going through assets, checking mechanics of a gameplay. Caution: You could be disturbing/distracting them from their work, respect their space and timings","title":"Emails? Slack? WhatsApp?"},{"location":"#workspace","text":"Write about office stuff, lunch, theatre room, devices/office assets checked out of office..etc Work timings, code of conduct","title":"Workspace"},{"location":"best-practices/","text":"Best Practices An accumlation of what we have learnt from our previous and current projects, what works and what doesn't work, and where it can be improved. Naming Conventions This has been one of the nightmares in our studios, hopefully artists also follow these steps, but by the end of the day, developers are the one who puts the project together, so make sure you maintain these standards. Project Folder Structure Try to maintain this folder structure for all of the projects, its not strict and are subjected to change as per project requirements. ProjectFolder (sheep-battle) |-Assets |-Media |-Sprites |-UI |-Game |-Audio |-SFX |-Music |-Shaders |-Materials |-Fonts |-Packs |-Scripts |-Game |-UI |-Misc |-Scenes |-Prefabs |-Game |-UI |-Plugins Filenames This one is bit tricky because it changes from project type and the file type. The general idea is not to you spaces in the filename, you can use a combination for UpperCamelCase HealthBar and dashes HealthBar-Highlight <DescriptionNameOfTheFile>-<ContextOfTheFile>-<MoreContext>... Back-Button Alert-Confirmation Alert-Window SheepBattle-Icon SheepBattle-Splash Try to group similar context to folders to keep things organized. Coding Namespaces and Classes All the class names and namespaces are in UpperCamelCase this included both C# and Typescript. Namespaces start with Hammerplay.<ProductName> make sure you use them from the start for easy organization. If it's a common code just use Hammerplay . // C# namespace Hammerplay.SheepBattle { public class GameManager: Monobehavior { // Code here } } // Typescript export default class SheepController { } Variables, Properties, Constants, Enums Both private and public variables are all on lowerCamelCase healthMeter Properties should be used with UpperCamelCase GameState On the other hand, both enums and constants are named in UPPER_CASE GAME_OVER // If you want to expose the member variable in inspector don't use public [SerializedField] private int healthMeter; // Properties and methods are only way to access the object from outside // variables should never be directly exposed to other class. public int GameState {private set; get}; // Try to have your defines in one class just like in C++ public const int START_POSITION = 0; public enum GAME_STATE { READY, IN_GAME, PAUSED, GAME_OVER } Singletons and Managers Managers are very useful to manage and maintain objects in a game, and objects accessing properties, methods and other managers through them. If Bullet objects want to access Player object, it can access through GameManager or if it happens through Physics callbacks such as OnTriggerEnter or OnCollisionEnter They are useful for grouping functionality such as UIManager , PoolManager , ConnectionManager It's not a good practice to have the Player class as singelton. So how do we access them? Don't ever use the method Find(\"GameManager\").GetComponent<GameManager> this is very slow and not efficient at all. Since we know only one of them is going to be there, Singletons to the rescue. GameManager public class GameManager: MonoBehaviour { private static GameManager instance; // This stores the one instance of the object as static. private void Awake () { instance = this; // We'll assign the first instance as static } private int totalScore; // If there's a static method of the same name, // since it's accessible publicly add _ to the local method private void _UpdateScore (int score) { totalScore += score; } // This method will be accessible to every other class in the game public void static UpdateScore (int score){ instance._UpdateScore (score); } } Player public class Player: MonoBehaviour { private void KillEnemy () { // This way it's much cleaner to access and easy to maintain GameManager.UpdateScore (10); } } Delegates and Events Managers as singletons are great to call a method from another object without having a reference to it, but what if your Managers want to notify other objects of some change such when game time runs out, or player pickups up a power up and enemy behavior needs to change. Event callbacks are very useful for Managers to notify other objects, without other objects constantly listening to it in a Update loop. GameManager public class GameManager: MonoBehaviour { private static GameManager instance; // This stores the one instance of the object as static. private void Awake () { instance = this; // We'll assign the first instance as static } private int totalScore; // If there's a static method of the same name, // since it's accessible publicly add _ to the local method private void _UpdateScore (int score) { totalScore += score; // Notify any listeners that there has been a score change if (OnScoreChanged != null) OnScoreChanged (totalScore); } // Make sure the delegates have 'Handler' in them. // This is basically a template of how event callback method should be. public delegate void ScoreHandler (int score); // Use the word, Add, Remove, Changed depending on the event // Events should start with the word 'On' before, just like OnClick, OnMouse public static event ScoreHandler OnScoreChanged; // This method will be accessible to every other class in the game public void static UpdateScore (int score){ instance._UpdateScore (score); } } UIManager public class UIManager: MonoBehaviour { [Serialized] private Text scoreText; private void OnEnable () { // Subscribe to event changes GameManager.OnScoreChanged += GameManager_OnScoreChanged; } private void OnDisable () { // Always remember to unsubscribe events. GameManager.OnScoreChanged -= GameManager_OnScoreChanged; } // This method is the exact template of the delegate // This method will be called whenever there's a score change. private void GameManager_OnScoreChanged (int score) { scoreText.text = string.Format (\"Score:{0}\", score); } } In this way, everything is very modular. The player doesn't directly talk with the UIManager, the score is updated and notified to which ever object is listening to it.","title":"Best Practices"},{"location":"best-practices/#best-practices","text":"An accumlation of what we have learnt from our previous and current projects, what works and what doesn't work, and where it can be improved.","title":"Best Practices"},{"location":"best-practices/#naming-conventions","text":"This has been one of the nightmares in our studios, hopefully artists also follow these steps, but by the end of the day, developers are the one who puts the project together, so make sure you maintain these standards.","title":"Naming Conventions"},{"location":"best-practices/#project-folder-structure","text":"Try to maintain this folder structure for all of the projects, its not strict and are subjected to change as per project requirements. ProjectFolder (sheep-battle) |-Assets |-Media |-Sprites |-UI |-Game |-Audio |-SFX |-Music |-Shaders |-Materials |-Fonts |-Packs |-Scripts |-Game |-UI |-Misc |-Scenes |-Prefabs |-Game |-UI |-Plugins","title":"Project Folder Structure"},{"location":"best-practices/#filenames","text":"This one is bit tricky because it changes from project type and the file type. The general idea is not to you spaces in the filename, you can use a combination for UpperCamelCase HealthBar and dashes HealthBar-Highlight <DescriptionNameOfTheFile>-<ContextOfTheFile>-<MoreContext>... Back-Button Alert-Confirmation Alert-Window SheepBattle-Icon SheepBattle-Splash Try to group similar context to folders to keep things organized.","title":"Filenames"},{"location":"best-practices/#coding","text":"","title":"Coding"},{"location":"best-practices/#namespaces-and-classes","text":"All the class names and namespaces are in UpperCamelCase this included both C# and Typescript. Namespaces start with Hammerplay.<ProductName> make sure you use them from the start for easy organization. If it's a common code just use Hammerplay . // C# namespace Hammerplay.SheepBattle { public class GameManager: Monobehavior { // Code here } } // Typescript export default class SheepController { }","title":"Namespaces and Classes"},{"location":"best-practices/#variables-properties-constants-enums","text":"Both private and public variables are all on lowerCamelCase healthMeter Properties should be used with UpperCamelCase GameState On the other hand, both enums and constants are named in UPPER_CASE GAME_OVER // If you want to expose the member variable in inspector don't use public [SerializedField] private int healthMeter; // Properties and methods are only way to access the object from outside // variables should never be directly exposed to other class. public int GameState {private set; get}; // Try to have your defines in one class just like in C++ public const int START_POSITION = 0; public enum GAME_STATE { READY, IN_GAME, PAUSED, GAME_OVER }","title":"Variables, Properties, Constants, Enums"},{"location":"best-practices/#singletons-and-managers","text":"Managers are very useful to manage and maintain objects in a game, and objects accessing properties, methods and other managers through them. If Bullet objects want to access Player object, it can access through GameManager or if it happens through Physics callbacks such as OnTriggerEnter or OnCollisionEnter They are useful for grouping functionality such as UIManager , PoolManager , ConnectionManager It's not a good practice to have the Player class as singelton. So how do we access them? Don't ever use the method Find(\"GameManager\").GetComponent<GameManager> this is very slow and not efficient at all. Since we know only one of them is going to be there, Singletons to the rescue. GameManager public class GameManager: MonoBehaviour { private static GameManager instance; // This stores the one instance of the object as static. private void Awake () { instance = this; // We'll assign the first instance as static } private int totalScore; // If there's a static method of the same name, // since it's accessible publicly add _ to the local method private void _UpdateScore (int score) { totalScore += score; } // This method will be accessible to every other class in the game public void static UpdateScore (int score){ instance._UpdateScore (score); } } Player public class Player: MonoBehaviour { private void KillEnemy () { // This way it's much cleaner to access and easy to maintain GameManager.UpdateScore (10); } }","title":"Singletons and Managers"},{"location":"best-practices/#delegates-and-events","text":"Managers as singletons are great to call a method from another object without having a reference to it, but what if your Managers want to notify other objects of some change such when game time runs out, or player pickups up a power up and enemy behavior needs to change. Event callbacks are very useful for Managers to notify other objects, without other objects constantly listening to it in a Update loop. GameManager public class GameManager: MonoBehaviour { private static GameManager instance; // This stores the one instance of the object as static. private void Awake () { instance = this; // We'll assign the first instance as static } private int totalScore; // If there's a static method of the same name, // since it's accessible publicly add _ to the local method private void _UpdateScore (int score) { totalScore += score; // Notify any listeners that there has been a score change if (OnScoreChanged != null) OnScoreChanged (totalScore); } // Make sure the delegates have 'Handler' in them. // This is basically a template of how event callback method should be. public delegate void ScoreHandler (int score); // Use the word, Add, Remove, Changed depending on the event // Events should start with the word 'On' before, just like OnClick, OnMouse public static event ScoreHandler OnScoreChanged; // This method will be accessible to every other class in the game public void static UpdateScore (int score){ instance._UpdateScore (score); } } UIManager public class UIManager: MonoBehaviour { [Serialized] private Text scoreText; private void OnEnable () { // Subscribe to event changes GameManager.OnScoreChanged += GameManager_OnScoreChanged; } private void OnDisable () { // Always remember to unsubscribe events. GameManager.OnScoreChanged -= GameManager_OnScoreChanged; } // This method is the exact template of the delegate // This method will be called whenever there's a score change. private void GameManager_OnScoreChanged (int score) { scoreText.text = string.Format (\"Score:{0}\", score); } } In this way, everything is very modular. The player doesn't directly talk with the UIManager, the score is updated and notified to which ever object is listening to it.","title":"Delegates and Events"}]}