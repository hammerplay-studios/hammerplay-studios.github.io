{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started There's an expectation from every developer nowadays. These are the set of tools that you require to get started before jumping into a project. Setting up version control Any company immediately checks whether you have a Github account; it's like a developer's business card. Once you have created your account, give your GitHub handle to your Technical Lead so he can add you to the company's team account. Learn the concepts of git like clone , push , pull , branches , merge , rebase and pull requests Please learn the concepts of Git Git tutorials Git Clients Git Fork (Free/Paid) Source Tree (Free) Git Tower (Paid) Magit (Free) CLI like a pro (Free) Tips Make sure you have a professional GitHub handle, please don't use \"Hammerplay\" name in it; Even after you leave the company, you still want to continue using that account. Do not work on the main branch right after you create a repository. After you either add README.md or .gitignore, Create a develop branch and push your code in that branch. Plan your .gitignore from start or copy it from an other project. Folders like Builds should be ignored from the beginning. Try to avoid commiting files then try to ignore it later. Do not keep your project files inside sub-folders. For example, Unity project should have Assets in the root of the git folder. Keep your projects organized in one projects folder. Naming conventions are crucial, we will cover more on that in best practices. Root git folder name should be in lowercases and use '-' as space. For example sheep-battle . When working with binary files like your images, sounds, textures, and scenes ; Communicate with the other team members, other wise you'll be stepping toes during git merge and losing data. Make smaller commits or follow git-flow method. Communication Teamwork is essential at Hammerplay; we follow Agile methodologies (mostly). To simplify the concepts, we do not have project managers, which means we have to communicate with the rest of the team by ourselves. If you need an asset? You either need to talk with your producer or talk directly with the artist/developer. How do ideas form and who makes the call?! Scrum/floor discussion, we talk about what we want to achieve and what the project ideas are, then we vote on the ideas as a group and make a list and try to go by that list. It's messy, but it works best with creative projects. Milestones Once the project is discussed each of the teammates comes up with estimates on how long it'll take, and further break down these milestones as prototype, alpha, internal beta, public beta, and release , there are no work timings, we just expect the milestones to be done with the estimates that you have already given. Sometimes estimates could be off, please raise a flag if things are not going by your timelines and talk to your team for updated action plans. Sync up with your team at least two times a week. Emails? Slack? WhatsApp? Mails : Only use for official talks, like talking to a client, even though most clients jump on Slack channels nowadays. WhatsApp : Avoid project discussions here unless you want to notify someone who is not reachable by Slack. You can say \"you're not coming for work\" , or \"you'll be late\" or just share memes. Slack : Post pandemic, Slack has completely changed how we work at our office. And moving forward, we'll be using this method regardless. Projects are usually in each channel, so keep your project discussions inside that channel and don't bother people on direct messaging unless it's private. Floor : Floor talk is the easiest form so far, this is best for us to do iterations, like going through assets or check game mechanics. Caution: You could be disturbing/distracting them from doing their work. Respect people's space and timings. Workspace Write about office stuff, lunch, theatre room, devices/office assets checked out of office..etc Work timings, code of conduct","title":"Getting Started"},{"location":"#getting-started","text":"There's an expectation from every developer nowadays. These are the set of tools that you require to get started before jumping into a project.","title":"Getting Started"},{"location":"#setting-up-version-control","text":"Any company immediately checks whether you have a Github account; it's like a developer's business card. Once you have created your account, give your GitHub handle to your Technical Lead so he can add you to the company's team account. Learn the concepts of git like clone , push , pull , branches , merge , rebase and pull requests Please learn the concepts of Git Git tutorials","title":"Setting up version control"},{"location":"#git-clients","text":"Git Fork (Free/Paid) Source Tree (Free) Git Tower (Paid) Magit (Free) CLI like a pro (Free)","title":"Git Clients"},{"location":"#tips","text":"Make sure you have a professional GitHub handle, please don't use \"Hammerplay\" name in it; Even after you leave the company, you still want to continue using that account. Do not work on the main branch right after you create a repository. After you either add README.md or .gitignore, Create a develop branch and push your code in that branch. Plan your .gitignore from start or copy it from an other project. Folders like Builds should be ignored from the beginning. Try to avoid commiting files then try to ignore it later. Do not keep your project files inside sub-folders. For example, Unity project should have Assets in the root of the git folder. Keep your projects organized in one projects folder. Naming conventions are crucial, we will cover more on that in best practices. Root git folder name should be in lowercases and use '-' as space. For example sheep-battle . When working with binary files like your images, sounds, textures, and scenes ; Communicate with the other team members, other wise you'll be stepping toes during git merge and losing data. Make smaller commits or follow git-flow method.","title":"Tips"},{"location":"#communication","text":"Teamwork is essential at Hammerplay; we follow Agile methodologies (mostly). To simplify the concepts, we do not have project managers, which means we have to communicate with the rest of the team by ourselves. If you need an asset? You either need to talk with your producer or talk directly with the artist/developer.","title":"Communication"},{"location":"#how-do-ideas-form-and-who-makes-the-call","text":"Scrum/floor discussion, we talk about what we want to achieve and what the project ideas are, then we vote on the ideas as a group and make a list and try to go by that list. It's messy, but it works best with creative projects.","title":"How do ideas form and who makes the call?!"},{"location":"#milestones","text":"Once the project is discussed each of the teammates comes up with estimates on how long it'll take, and further break down these milestones as prototype, alpha, internal beta, public beta, and release , there are no work timings, we just expect the milestones to be done with the estimates that you have already given. Sometimes estimates could be off, please raise a flag if things are not going by your timelines and talk to your team for updated action plans. Sync up with your team at least two times a week.","title":"Milestones"},{"location":"#emails-slack-whatsapp","text":"Mails : Only use for official talks, like talking to a client, even though most clients jump on Slack channels nowadays. WhatsApp : Avoid project discussions here unless you want to notify someone who is not reachable by Slack. You can say \"you're not coming for work\" , or \"you'll be late\" or just share memes. Slack : Post pandemic, Slack has completely changed how we work at our office. And moving forward, we'll be using this method regardless. Projects are usually in each channel, so keep your project discussions inside that channel and don't bother people on direct messaging unless it's private. Floor : Floor talk is the easiest form so far, this is best for us to do iterations, like going through assets or check game mechanics. Caution: You could be disturbing/distracting them from doing their work. Respect people's space and timings.","title":"Emails? Slack? WhatsApp?"},{"location":"#workspace","text":"Write about office stuff, lunch, theatre room, devices/office assets checked out of office..etc Work timings, code of conduct","title":"Workspace"},{"location":"best-practices/","text":"Best Practices An accumulation of what we have learned from our previous and current projects, we took what works and what doesn't, and where it can be improved. Naming Conventions Naming convention has been one of the nightmares in our studios hopefully, artists also follow these steps, but by the end of the day, developers are the one who puts the project together, so make sure you maintain these standards. Project Folder Structure Try to maintain this folder structure for all projects; it's not strict and is subjected to change as per project requirements. ProjectFolder (sheep-battle) |-Assets |-Media |-Sprites |-UI |-Game |-Audio |-SFX |-Music |-Shaders |-Materials |-Fonts |-Packs |-Scripts |-Game |-UI |-Misc |-Scenes |-Prefabs |-Game |-UI |-Plugins Filenames This one is a bit tricky because it changes from the project type and the file type. The general idea is not to use spaces in a filename; you can use a combination for UpperCamelCase HealthBar and dashes HealthBar-Highlight <DescriptionNameOfTheFile>-<ContextOfTheFile>-<MoreContext>... Back-Button Alert-Confirmation Alert-Window SheepBattle-Icon SheepBattle-Splash Try to group similar context to folders to keep things organized. Coding Namespaces and Classes All the class names and namespaces are in UpperCamelCase this included both C# and Typescript. Namespaces start with Hammerplay.<ProductName> make sure you use them from the start for easy organization. If it's a common code just use Hammerplay . // C# namespace Hammerplay.SheepBattle { public class GameManager: Monobehavior { // Code here } } // Typescript export default class SheepController { } Variables, Properties, Constants, Enums Both private and public variables are all on lowerCamelCase healthMeter Properties should be used with UpperCamelCase GameState On the other hand, both enums and constants are named in UPPER_CASE `GAME_OVER // If you want to expose the member variable in inspector don't use public [SerializedField] private int healthMeter; // Properties and methods are only way to access the object from outside // variables should never be directly exposed to other class. public int GameState {private set; get}; // Try to have your defines in one class just like in C++ public const int START_POSITION = 0; public enum GAME_STATE { READY, IN_GAME, PAUSED, GAME_OVER } Singletons and Managers Managers are useful to manage and maintain objects in a game. Objects can access properties, methods, and other managers through them. If Bullet objects want to access a Player object, it can access through GameManager or if it happens through Physics callbacks such as OnTriggerEnter or OnCollisionEnter Managers are useful for grouping functionality such as UIManager , PoolManager , ConnectionManager It's not a good practice to have the Player class as Singleton. So how do we access them? Don't ever use the method Find(\"GameManager\").GetComponent<GameManager> this is very slow and not efficient at all; since we know only one of them is going to be there, Singletons to the rescue. GameManager public class GameManager: MonoBehaviour { private static GameManager instance; // This stores the one instance of the object as static. private void Awake () { instance = this; // We'll assign the first instance as static } private int totalScore; // If there's a static method of the same name, // since it's accessible publicly add _ to the local method private void _UpdateScore (int score) { totalScore += score; } // This method will be accessible to every other class in the game public void static UpdateScore (int score){ instance._UpdateScore (score); } } Player public class Player: MonoBehaviour { private void KillEnemy () { // This way it's much cleaner to access and easy to maintain GameManager.UpdateScore (10); } } Delegates and Events Managers as singletons make it easy to call a method from another object without having a reference to it, but what if your Managers want to notify other objects of some change that happened in the game, such as when game time runs out, or player pickups up a power-up and enemy behavior needs to change. Event callbacks are very useful for Managers to notify other objects, without other objects constantly listening to them in a Update loop. GameManager public class GameManager: MonoBehaviour { private static GameManager instance; // This stores the one instance of the object as static. private void Awake () { instance = this; // We'll assign the first instance as static } private int totalScore; // If there's a static method of the same name, // since it's accessible publicly add _ to the local method private void _UpdateScore (int score) { totalScore += score; // Notify any listeners that there has been a score change if (OnScoreChanged != null) OnScoreChanged (totalScore); } // Make sure the delegates have 'Handler' in them. // This is basically a template of how event callback method should be. public delegate void ScoreHandler (int score); // Use the word, Add, Remove, Changed depending on the event // Events should start with the word 'On' before, just like OnClick, OnMouse public static event ScoreHandler OnScoreChanged; // This method will be accessible to every other class in the game public void static UpdateScore (int score){ instance._UpdateScore (score); } } UIManager public class UIManager: MonoBehaviour { [Serialized] private Text scoreText; private void OnEnable () { // Subscribe to event changes GameManager.OnScoreChanged += GameManager_OnScoreChanged; } private void OnDisable () { // Always remember to unsubscribe events. GameManager.OnScoreChanged -= GameManager_OnScoreChanged; } // This method is the exact template of the delegate // This method will be called whenever there's a score change. private void GameManager_OnScoreChanged (int score) { scoreText.text = string.Format (\"Score:{0}\", score); } } In this way, everything is modular. The player doesn't directly need to talk with the UIManager; the score is updated and notified to whichever object is listening to it.","title":"Best Practices"},{"location":"best-practices/#best-practices","text":"An accumulation of what we have learned from our previous and current projects, we took what works and what doesn't, and where it can be improved.","title":"Best Practices"},{"location":"best-practices/#naming-conventions","text":"Naming convention has been one of the nightmares in our studios hopefully, artists also follow these steps, but by the end of the day, developers are the one who puts the project together, so make sure you maintain these standards.","title":"Naming Conventions"},{"location":"best-practices/#project-folder-structure","text":"Try to maintain this folder structure for all projects; it's not strict and is subjected to change as per project requirements. ProjectFolder (sheep-battle) |-Assets |-Media |-Sprites |-UI |-Game |-Audio |-SFX |-Music |-Shaders |-Materials |-Fonts |-Packs |-Scripts |-Game |-UI |-Misc |-Scenes |-Prefabs |-Game |-UI |-Plugins","title":"Project Folder Structure"},{"location":"best-practices/#filenames","text":"This one is a bit tricky because it changes from the project type and the file type. The general idea is not to use spaces in a filename; you can use a combination for UpperCamelCase HealthBar and dashes HealthBar-Highlight <DescriptionNameOfTheFile>-<ContextOfTheFile>-<MoreContext>... Back-Button Alert-Confirmation Alert-Window SheepBattle-Icon SheepBattle-Splash Try to group similar context to folders to keep things organized.","title":"Filenames"},{"location":"best-practices/#coding","text":"","title":"Coding"},{"location":"best-practices/#namespaces-and-classes","text":"All the class names and namespaces are in UpperCamelCase this included both C# and Typescript. Namespaces start with Hammerplay.<ProductName> make sure you use them from the start for easy organization. If it's a common code just use Hammerplay . // C# namespace Hammerplay.SheepBattle { public class GameManager: Monobehavior { // Code here } } // Typescript export default class SheepController { }","title":"Namespaces and Classes"},{"location":"best-practices/#variables-properties-constants-enums","text":"Both private and public variables are all on lowerCamelCase healthMeter Properties should be used with UpperCamelCase GameState On the other hand, both enums and constants are named in UPPER_CASE `GAME_OVER // If you want to expose the member variable in inspector don't use public [SerializedField] private int healthMeter; // Properties and methods are only way to access the object from outside // variables should never be directly exposed to other class. public int GameState {private set; get}; // Try to have your defines in one class just like in C++ public const int START_POSITION = 0; public enum GAME_STATE { READY, IN_GAME, PAUSED, GAME_OVER }","title":"Variables, Properties, Constants, Enums"},{"location":"best-practices/#singletons-and-managers","text":"Managers are useful to manage and maintain objects in a game. Objects can access properties, methods, and other managers through them. If Bullet objects want to access a Player object, it can access through GameManager or if it happens through Physics callbacks such as OnTriggerEnter or OnCollisionEnter Managers are useful for grouping functionality such as UIManager , PoolManager , ConnectionManager It's not a good practice to have the Player class as Singleton. So how do we access them? Don't ever use the method Find(\"GameManager\").GetComponent<GameManager> this is very slow and not efficient at all; since we know only one of them is going to be there, Singletons to the rescue. GameManager public class GameManager: MonoBehaviour { private static GameManager instance; // This stores the one instance of the object as static. private void Awake () { instance = this; // We'll assign the first instance as static } private int totalScore; // If there's a static method of the same name, // since it's accessible publicly add _ to the local method private void _UpdateScore (int score) { totalScore += score; } // This method will be accessible to every other class in the game public void static UpdateScore (int score){ instance._UpdateScore (score); } } Player public class Player: MonoBehaviour { private void KillEnemy () { // This way it's much cleaner to access and easy to maintain GameManager.UpdateScore (10); } }","title":"Singletons and Managers"},{"location":"best-practices/#delegates-and-events","text":"Managers as singletons make it easy to call a method from another object without having a reference to it, but what if your Managers want to notify other objects of some change that happened in the game, such as when game time runs out, or player pickups up a power-up and enemy behavior needs to change. Event callbacks are very useful for Managers to notify other objects, without other objects constantly listening to them in a Update loop. GameManager public class GameManager: MonoBehaviour { private static GameManager instance; // This stores the one instance of the object as static. private void Awake () { instance = this; // We'll assign the first instance as static } private int totalScore; // If there's a static method of the same name, // since it's accessible publicly add _ to the local method private void _UpdateScore (int score) { totalScore += score; // Notify any listeners that there has been a score change if (OnScoreChanged != null) OnScoreChanged (totalScore); } // Make sure the delegates have 'Handler' in them. // This is basically a template of how event callback method should be. public delegate void ScoreHandler (int score); // Use the word, Add, Remove, Changed depending on the event // Events should start with the word 'On' before, just like OnClick, OnMouse public static event ScoreHandler OnScoreChanged; // This method will be accessible to every other class in the game public void static UpdateScore (int score){ instance._UpdateScore (score); } } UIManager public class UIManager: MonoBehaviour { [Serialized] private Text scoreText; private void OnEnable () { // Subscribe to event changes GameManager.OnScoreChanged += GameManager_OnScoreChanged; } private void OnDisable () { // Always remember to unsubscribe events. GameManager.OnScoreChanged -= GameManager_OnScoreChanged; } // This method is the exact template of the delegate // This method will be called whenever there's a score change. private void GameManager_OnScoreChanged (int score) { scoreText.text = string.Format (\"Score:{0}\", score); } } In this way, everything is modular. The player doesn't directly need to talk with the UIManager; the score is updated and notified to whichever object is listening to it.","title":"Delegates and Events"}]}